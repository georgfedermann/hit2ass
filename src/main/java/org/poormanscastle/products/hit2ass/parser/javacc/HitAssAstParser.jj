/*
This is the hit2ass transformer JavaCC based lexer and parser configuration.

Both, the lexer and the grammar rules are the result of reverse engineering of the
available sources within the legacy project.

All legacy files (i.e. document templates and business data input text files) are provided in ISO-8859-1 encoding
(not UTF-8).
Nota bene: The JavaCC system expects the encoding name to be given in this form: ISO8859_1
or it will not be recognized by the system. In particular, the wording ISO-8859-1 is not recognized by the system.

This document uses the following conventions:

parenthesis, bracket, brace
===========================
To avoid nomenclature like left curly brace, closing round bracket, and squiggly parentheses,
this document uses the conventions as quoted below.
(       left parenthesis
)       right parenthesis
[       left bracket
]       right bracket
{       left brace
}       right brace

German Umlauts
==============
The legacy project provides ISO-8859-1 encoded document templates and business data input text files.
Here is a list of the ISO-8859-1 sequences for the umlauts, which are used in the lexer definitions below.
  ISO8859_1 sequences for German special characters:
  ä "\u00e4"
  ö "\u00f6"
  ü "\u00fc"
  Ä "\u00c4"
  Ö "\u00d6"
  Ü "\u00dc"
  ß "\u00df"
  _ "\u00a0"    weird underscore character in HIT / CLOU editor

Nonterminal symbols, syntactic variables, expandables
=====================================================
This is a list of the terminal symbols used in the lexer specification in text mode
    AS      ... Assignment Statement #=
    CA      ... Case, works in the context of a switch statement (SS), /id
    DV      ... Dynamic Value #X<
    FX      ... Fixed Text
    GDS     ... Global Declaration Statement
    GS      ... G statement, for setting of cursor positions #G
    HC      ... Hit Command
    IF      ... Conditional Statement #?
    IB      ... Import Baustein	#B
    JS      ... J statement, for setting of cursor positions #J
    LDS     ... Local Declaration Statement
    MS      ... Macro Statement, generic execution statement, interprets to content of a text variable as CLOU sources #$
    OF      ... Handling files, like opening and closing them. Historically derives from "Open file"
    PS      ... Print statement, for printing the evaluation result of IdExpressions #>
    SB      ... Section break @
    SK      ... Shell Kommando
    SS      ... SwitchStatement #C
    WS      ... While Statement #S
    ZS      ... Z statement, used to query the current cursor position #Z

This is a list of the expandables / non-terminal symbols / lexical variables

    CB      ... ClouBaustein
    CBE     ... Clou Baustein Element
    CBES    ... Clou Baustein Element Specific


*/

/* Parser configuration options. */
options{
    LOOKAHEAD = 1;
    BUILD_PARSER = true;
    BUILD_TOKEN_MANAGER = true;
    CHOICE_AMBIGUITY_CHECK = 2;
    DEBUG_LOOKAHEAD = false;
    DEBUG_PARSER = false;
    DEBUG_TOKEN_MANAGER = false;
    ERROR_REPORTING = true;
    FORCE_LA_CHECK = false;
    IGNORE_CASE = false;
    JAVA_UNICODE_ESCAPE = false;
    OTHER_AMBIGUITY_CHECK = 1;
    SANITY_CHECK = true;
    STATIC = false; /* changed */
    UNICODE_INPUT = false; /* not changed */
    USER_CHAR_STREAM = false;
    USER_TOKEN_MANAGER = false;
}

PARSER_BEGIN(HitAssAstParser)
package org.poormanscastle.products.hit2ass.parser.javacc;

import org.poormanscastle.products.hit2ass.ast.domain.*;
import org.poormanscastle.products.hit2ass.exceptions.*;

import org.apache.commons.lang3.StringUtils;
import org.apache.log4j.Logger;

public class HitAssAstParser{
    private final static Logger logger = Logger.getLogger(HitAssAstParser.class);
    public static void main(String[] args){
        logger.info(StringUtils.join("Running parser with encoding hit2ass.clou.encoding=",
            System.getProperty("hit2ass.clou.encoding")));
        HitAssAstParser parser = new HitAssAstParser(System.in, System.getProperty("hit2ass.clou.encoding"));
    }
}
PARSER_END(HitAssAstParser)

// CLOU Baustein
TOKEN : {
    < CLOU_OPENER : "#"("\n"|"\r") > : TXT_MODE
}

/*

*/

// CLOU comments; single line, multi-line and empty comments
<TXT_MODE> MORE : {
    "#*" : COMMENT_MODE
}
<COMMAND_MODE_DS> MORE : {
    "#*" : COMMENT_MODE
}
<COMMAND_MODE_SS> MORE : {
    "#*" : COMMENT_MODE
}
<COMMAND_MODE_AS> MORE : {
    "#*" : COMMENT_MODE
}
<COMMAND_MODE_MS> MORE : {
    "#*" : COMMENT_MODE
}
<COMMENT_MODE> SPECIAL_TOKEN : {
    <END_COMMENT : "#"> : TXT_MODE
}
<COMMENT_MODE> MORE : {
    <~["#"]>
}

/*  TEXT_MODE switching to COMMAND_MODE.    */
<TXT_MODE> TOKEN : {
    < IF : "#?" > : COMMAND_MODE_IF |
    < THEN : "/J" > : TXT_MODE |
    < ELSE : "/N" > : TXT_MODE |
    < ENDIF : "#" > : TXT_MODE |            //
    < SB : "@" > : TXT_MODE |          // represents a section break. TODO when adapting this tool to a project, find a character that fits your document base and configure procon accordingly
    < WS : "#S" > : COMMAND_MODE_IF |       // While loop statement
    < FS : "#W" > : COMMAND_MODE_FOR |       // FOR loop, fixed number of repetitions; a new mode is in order because FOR loops have their own syntax, thus mode switches in command_mode_for occur differently than it's the case in command_mode_if
    < SS : "#C" > : COMMAND_MODE_SS |       // Switch statement
    < CA : "/"(((["0"-"9"])+)|("\""(["0"-"9","a"-"z", "A"-"Z"])+"\"")?)":" > : TXT_MODE | // < CA : "/"(["0"-"9"])+|("\""(["0"-"9","a"-"z", "A"-"Z"])+"\"")":" >
    < MS : "#$" > : COMMAND_MODE_MS |       // execute Macro
    < HC : "#^" > : COMMAND_MODE_HC |       // execute Hit command
    < GS : "#G" > : COMMAND_MODE_DS |       // set cursor location in row
    < JS : "#J" > : COMMAND_MODE_DS |       // set cursor location row/column
    < ZS : "#Z" > : COMMAND_MODE_DS |       // Query cursor location
    < GD : "#D" > : COMMAND_MODE_DS |       // Global variable declaration statements
    < LD : "#d" > : COMMAND_MODE_DS |       // Local variable declaration statements
    < LIST : "#L" > : COMMAND_MODE_LS |     // List Manipulations
    < DUMP : "#q" > : COMMAND_MODE_DUMP |
    < AS : "#=" > : COMMAND_MODE_AS |       // Assignment Statemeent
    < IB : "#B" > : COMMAND_MODE_IB |       // Include Baustein statement
    < OF : "#X" > : COMMAND_MODE_FILE |     // File manipulation statements, like: open file, close file, read value from file.
    < DV : "#X"([" ", "\n", "\r", "\t"])*"<" > : COMMAND_MODE_DV |
    < PS : "#>" >  : COMMAND_MODE_PS |      // Print-Statement: Insert value of some given expression at the current position into the current document
    < SK : "#!" > : COMMAND_MODE_SK         // Execute Shell command
}

/*  Fixed text mode */
<TXT_MODE> TOKEN : {
    <FIXED_TEXT : (~["\n", "\r", "\t", " ", "#", "@" ])+ >
}

<TXT_MODE> SKIP : {
    "\n" | "\r" | "\t" | " "
}
<COMMAND_MODE_DV> TOKEN : {
    < DV_ID : [ "_", "a"-"z", "A"-"Z"]([ "_", "a"-"z", "A"-"Z", "0"-"9" ])* > : TXT_MODE
}
<COMMAND_MODE_DV> SKIP : {
    "\n" | "\r" | "\t" | " "
}
<COMMAND_MODE_FILE> TOKEN : {
    < FILE_OPEN : "O" > |
    < FILE_CLOSE : "C" > : TXT_MODE |
    < FILE_READ : "\"r\"" > : TXT_MODE |
    < FILE_TEXT : (["A"-"Z", "a"-"z", "\"", "$", "(", ")", "/", "0"-"9", "-", "_", "." ])+ > // If you want to work with optional file names here, you'll have to implement it in the production rules, or else this rule matches the empty string and kills the parser.
}
<COMMAND_MODE_FILE> SKIP : {
    "\n" | "\r" | "\t" | " "
}
<COMMAND_MODE_IB> TOKEN : {
    < IB_TEXT : "\""
        (
            "\\" ~[]
        |
            ~["\""]     // this covers the HIT/CLOU protected space character and also all German Umlauts.
        )*"\"" > : TXT_MODE
}
<COMMAND_MODE_IB> SKIP : {
    "\n" | "\r" | "\t" | " "
}
<COMMAND_MODE_PS> SKIP : {
    "\n" | "\r" | "\t" | " "
}
<COMMAND_MODE_PS> TOKEN : {
    < PS_SB : "@" > : TXT_MODE |
    < PS_EQ : "=" > |
    < PS_EQ_STRICT : "==" > |
    < PS_OR : "oder" > |
    < PS_AND : "und" > |
    < PS_XOR : "xor_tbd" > |
    < PS_NOT : "not_tbd" > |
    < PS_NEQ : "<>" > |
    < PS_LT : "<" > |
    < PS_LTE : "<=" > |
    < PS_GT : ">" > |
    < PS_GTE : ">=" > |
    < PS_PLUS : "+" > |
    < PS_MINUS : "-" > |
    < PS_TIMES : "*" > |
    < PS_DIV : "/" > |
    < PS_QUOTE : "\"" > |
    < PS_LPAREN : "(" > |
    < PS_RPAREN : ")" > |
    < PS_NUM : (["0"-"9"])+ > |
    < PS_DEC : (["0"-"9"])+("."(["0"-"9"])+)? | ("."(["0"-"9"])+) > |
    < PS_ID : [ "_", "a"-"z", "A"-"Z"](["_", "a"-"z", "A"-"Z", "0"-"9",
            "\u00e4", "\u00f6", "\u00fc", "\u00df", "\u00c4", "\u00d6", "\u00dc", "\u00a0" ])* > : COMMAND_MODE_PS_IDX_CHECK
}
<COMMAND_MODE_PS_IDX_CHECK> TOKEN : {
    < PS_IDX_CHECK_LBRACKET : "[" > : COMMAND_MODE_PS_IDX |
    < PS_IDX_CHECK_FIXED_TEXT : ( ~[ "\n", "\r", "\t", " ", "#", "@", "[" ] ) > : TXT_MODE |
    < PS_IDX_SB : "@" > : TXT_MODE
}
<COMMAND_MODE_PS_IDX_CHECK> SKIP : {
    < PS_IDX_CHECK_SKIP : [ "\n", "\r", "\t", " " ] > : TXT_MODE
}
<COMMAND_MODE_PS_IDX> SKIP : {
    "\n" : TXT_MODE | "\t" : TXT_MODE | "\r" : TXT_MODE | " " : TXT_MODE
}
<COMMAND_MODE_PS_IDX> TOKEN : {
    < PS_IDX_LBRACKET : "[" > |
    < PS_IDX_RBRACKET : "]" > : TXT_MODE |
    < PS_IDX_EQ : "=" > |
    < PS_IDX_EQ_STRICT : "==" > |
    < PS_IDX_OR : "oder" > |
    < PS_IDX_AND : "und" > |
    < PS_IDX_XOR : "xor_tbd" > |
    < PS_IDX_NOT : "not_tbd" > |
    < PS_IDX_NEQ : "<>" > |
    < PS_IDX_LT : "<" > |
    < PS_IDX_LTE : "<=" > |
    < PS_IDX_GT : ">" > |
    < PS_IDX_GTE : ">=" > |
    < PS_IDX_PLUS : "+" > |
    < PS_IDX_MINUS : "-" > |
    < PS_IDX_TIMES : "*" > |
    < PS_IDX_DIV : "/" > |
    < PS_IDX_QUOTE : "\"" > |
    < PS_IDX_LPAREN : "(" > |
    < PS_IDX_RPAREN : ")" > |
    < PS_IDX_COMMA : "," > |
    < PS_IDX_NUM : (["0"-"9"])+ > |
    < PS_IDX_DEC : (["0"-"9"])+("."(["0"-"9"])+)? | ("."(["0"-"9"])+) > |
    < PS_IDX_ID : [ "_", "a"-"z", "A"-"Z"](["_", ",", "a"-"z", "A"-"Z", "0"-"9",
        "\u00e4", "\u00f6", "\u00fc", "\u00df", "\u00c4", "\u00d6", "\u00dc", "\u00a0" ])* >
}

<COMMAND_MODE_SS> SKIP : {
    "\n": TXT_MODE  | "\r": TXT_MODE  | "\t" | " "
}
<COMMAND_MODE_SS> TOKEN : {
    < SS_SHELLVAR : "SHELLVARIABLE" > |
    < SS_LPAREN : "(" > |
    < SS_RPAREN : ")" > : TXT_MODE |
    < SS_QUOTE : "\"" > |
    < SS_SHELLVAR_ID : (["A"-"Z"])+ > |
    < SS_COMMA : "," > |
    < SS_LBRACKET : "[" > |
    < SS_RBRACKET : "]" > |
    < SS_NUM : (["0"-"9"])+ > |
    < SS_ID : [ "_", "a"-"z", "A"-"Z" ]([ "_", "a"-"z", "A"-"Z", "0"-"9" ])* > |
    < CA_COLON : ":" > : TXT_MODE
}
<COMMAND_MODE_SK> TOKEN : {
    <SK_VAR_ID : (["$", "A"-"Z", "a"-"z", "0"-"9"])+ > : TXT_MODE
}
<COMMAND_MODE_SK> SKIP :{
    " " | "\n" | "\t" | "\r"
}
<COMMAND_MODE_MS> SKIP : {
    "\n" : TXT_MODE | "\r" : TXT_MODE | "\t" | " "
}
<COMMAND_MODE_MS> TOKEN : {
    < MS_EQ : "=" > |
    < MS_EQ_STRICT : "==" > |
    < MS_OR : "oder" > |
    < MS_AND : "und" > |
    < MS_XOR : "xor_tbd" > |
    < MS_NOT : "not_tbd" > |
    < MS_NEQ : "<>" > |
    < MS_LT : "<" > |
    < MS_LTE : "<=" > |
    < MS_GT : ">" > |
    < MS_GTE : ">=" > |
    < MS_PLUS : "+" > |
    < MS_MINUS : "-" > |
    < MS_TIMES : "*" > |
    < MS_DIV : "/" > |
    < MS_LPAREN : "(" > |
    < MS_RPAREN : ")" > : TXT_MODE |
    < MS_LBRACKET : "[" > |
    < MS_RBRACKET : "]" > |
    < MS_COMMA : "," > |
    < MS_NUM : (["0"-"9"])+ > |
    < MS_DEC : (["0"-"9"])+("."(["0"-"9"])+)? | ("."(["0"-"9"])+) > |
    < MS_ID : ( ~["#", "(", ")", ",", " ", "\t", "\n", "\r"])+ > | /* I've switched here from white list to black list because of the Umlauts in the actual Bausteins, but that might come back to hount me, either. */
    < MS_TEXT : "\""
        (
            "\\" ~[]
        |
            ~["\""]     // this covers the HIT/CLOU protected space character and also all German Umlauts.
        )*"\"" >

}
<COMMAND_MODE_IF> TOKEN : {
    < IF_SHELLVAR : "SHELLVARIABLE" > |
    < IF_EQ : "=" > |
    < IF_EQ_STRICT : "==" > |
    < IF_OR : "oder" > |
    < IF_AND : "und" > |
    < IF_XOR : "xor_tbd" > |
    < IF_NOT : "not_tbd" > |
    < IF_NEQ : "<>" > |
    < IF_LT : "<" > |
    < IF_LTE : "<=" > |
    < IF_GT : ">" > |
    < IF_GTE : ">=" > |
    < IF_PLUS : "+" > |
    < IF_MINUS : "-" > |
    < IF_TIMES : "*" > |
    < IF_DIV : "/" > |
    < IF_QUOTE : "\"" > |
    < IF_COLON : ":" > : TXT_MODE |
    < IF_LPAREN : "(" > |
    < IF_RPAREN : ")" > |
    < IF_NUM : (["0"-"9"])+ > |
    < IF_LBRACKET : "[" > |
    < IF_RBRACKET : "]" > |
    < IF_DEC : (["0"-"9"])+("."(["0"-"9"])+)? | ("."(["0"-"9"])+) > |
    < IF_SHELLVAR_ID : (["A"-"Z"])+ > |
    < IF_ID : [ "_", "a"-"z", "A"-"Z"](["_", "a"-"z", "A"-"Z", "0"-"9",
        "\u00e4", "\u00f6", "\u00fc", "\u00df", "\u00c4", "\u00d6", "\u00dc", "\u00a0" ])* > |
    < IF_TEXT : "\""
        (
            "\\" ~[]
        |
            ~["\""]     // this covers the HIT/CLOU protected space character and also all German Umlauts.
        )*"\"" >
}
<COMMAND_MODE_IF> SKIP : {
    "\n" | "\r" | "\t" | " "
}
<COMMAND_MODE_FOR> TOKEN : {
    < FOR_SHELLVAR : "SHELLVARIABLE" > |
    < FOR_EQ : "=" > |
    < FOR_EQ_STRICT : "==" > |
    < FOR_OR : "oder" > |
    < FOR_AND : "und" > |
    < FOR_XOR : "xor_tbd" > |
    < FOR_NOT : "not_tbd" > |
    < FOR_NEQ : "<>" > |
    < FOR_LT : "<" > |
    < FOR_LTE : "<=" > |
    < FOR_GT : ">" > |
    < FOR_GTE : ">=" > |
    < FOR_PLUS : "+" > |
    < FOR_MINUS : "-" > |
    < FOR_TIMES : "*" > |
    < FOR_DIV : "/" > |
    < FOR_QUOTE : "\"" > |
    < FOR_COLON : ":" > |
    < FOR_LPAREN : "(" > |
    < FOR_RPAREN : ")" > |
    < FOR_NUM : (["0"-"9"])+ > |
    < FOR_LBRACKET : "[" > |
    < FOR_RBRACKET : "]" > |
    < FOR_DEC : (["0"-"9"])+("."(["0"-"9"])+)? | ("."(["0"-"9"])+) > |
    < FOR_SHELLVAR_ID : (["A"-"Z"])+ > |
    < FOR_ID : [ "_", "a"-"z", "A"-"Z"](["_", "a"-"z", "A"-"Z", "0"-"9",
        "\u00e4", "\u00f6", "\u00fc", "\u00df", "\u00c4", "\u00d6", "\u00dc", "\u00a0" ])* > |
    < FOR_TEXT : "\""
        (
            "\\" ~[]
        |
            ~["\""]     // this covers the HIT/CLOU protected space character and also all German Umlauts.
        )*"\"" >
}
<COMMAND_MODE_FOR> SKIP : {
    "\n" : TXT_MODE | "\r" : TXT_MODE | "\t" | " "
}
<COMMAND_MODE_DS> TOKEN : {
    < DS_EQ : "=" > |
    < DS_EQ_STRICT : "==" > |
    < DS_OR : "oder" > |
    < DS_AND : "und" > |
    < DS_XOR : "xor_tbd" > |
    < DS_NOT : "not_tbd" > |
    < DS_NEQ : "<>" > |
    < DS_LT : "<" > |
    < DS_LTE : "<=" > |
    < DS_GT : ">" > |
    < DS_GTE : ">=" > |
    < DS_STRING_CONCAT : "&" > |
    < DS_PLUS : "+" > |
    < DS_MINUS : "-" > |
    < DS_TIMES : "*" > |
    < DS_DIV : "/" > |
    < DS_QUOTE : "\"" > |
    < DS_COLON : ":" > |
    < DS_COMMA : "," > |
    < DS_LPAREN : "(" > |
    < DS_RPAREN : ")" > |
    < DS_LBRACKET : "[" > |
    < DS_RBRACKET : "]" > |
    < DS_NUM : (["0"-"9"])+ > |
    < DS_DEC : (["0"-"9"])+("."(["0"-"9"])+)? | ("."(["0"-"9"])+) > |
    < DS_ID : [ "_", "a"-"z", "A"-"Z"](["_", "a"-"z", "A"-"Z", "0"-"9",
        "\u00e4", "\u00f6", "\u00fc", "\u00df", "\u00c4", "\u00d6", "\u00dc", "\u00a0" ])* > |
    < DS_TEXT : "\""
        (
            "\\" ~[]
        |
            ~["\""]     // this covers the HIT/CLOU protected space character and also all German Umlauts.
        )*"\"" >
}
<COMMAND_MODE_DS> SKIP : {
    "\n" : TXT_MODE | "\r" : TXT_MODE | "\t" | " "
}
<COMMAND_MODE_AS> TOKEN : {
    < AS_SHELLVAR : "SHELLVARIABLE" > |
    < AS_EQ : "=" > |
    < AS_EQ_STRICT : "==" > |
    < AS_OR : "oder" > |
    < AS_AND : "und" > |
    < AS_XOR : "xor_tbd" > |
    < AS_NOT : "not_tbd" > |
    < AS_NEQ : "<>" > |
    < AS_LT : "<" > |
    < AS_LTE : "<=" > |
    < AS_GT : ">" > |
    < AS_GTE : ">=" > |
    < AS_COMMA : "," > |
    < AS_STRING_CONCAT : "&" > |
    < AS_PLUS : "+" > |
    < AS_MINUS : "-" > |
    < AS_TIMES : "*" > |
    < AS_DIV : "/" > |
    < AS_QUOTE : "\"" > |
    < AS_COLON : ":" > |
    < AS_LPAREN : "(" > |
    // < AS_RPAREN : ")" > : TXT_MODE |    // why is this again switching to text mode?
    < AS_RPAREN : ")" > |
    < AS_LBRACKET : "[" > |
    // < AS_RBRACKET : "]" > : TXT_MODE |  // why is this again switching to text mode?
    < AS_RBRACKET : "]" > |
    < AS_NUM : (["0"-"9"])+ > |
    < AS_DEC : (["0"-"9"])+("."(["0"-"9"])+)? | ("."(["0"-"9"])+) > |
    < AS_SHELLVAR_ID : (["A"-"Z"])+ > |
    < AS_ID : [ "_", "a"-"z", "A"-"Z"](["_", "a"-"z", "A"-"Z", "0"-"9",
        "\u00e4", "\u00f6", "\u00fc", "\u00df", "\u00c4", "\u00d6", "\u00dc", "\u00a0" ])* > |
    < AS_TEXT : "\""
        (
            "\\" ~[]
        |
            ~["\""]     // this covers the HIT/CLOU protected space character and also all German Umlauts.
        )*"\"" >
}
<COMMAND_MODE_AS> SKIP : {
    "\n" : TXT_MODE | "\r" : TXT_MODE | "\t" | " "
}
<COMMAND_MODE_LS> TOKEN : {
    < LS_AMPERSAND : "&" > |
    < LS_LBRACE : "{" > : COMMAND_MODE_LS_BRACES |
    < LS_GD : "D" > |
    < LS_LD : "d" > |
    < LS_LBRACKET : "[" > |
    < LS_RBRACKET : "]" > |
    < LS_ID : [ "_", "a"-"z", "A"-"Z"](["_", "a"-"z", "A"-"Z", "0"-"9", "\u00a0"])* > |
    < LS_TEXT : "\""
        (
            "\\" ~[]
        |
            ~["\""]     // this covers the HIT/CLOU protected space character and also all German Umlauts and szlig.
        )*"\"" >
}
<COMMAND_MODE_LS> SKIP : {
    "\n" : TXT_MODE | "\r" : TXT_MODE | "\t" | " "
}
<COMMAND_MODE_DUMP> SKIP : {
    "\n" | "\r" | " " | "\t"
}
<COMMAND_MODE_DUMP> TOKEN : {
    < DUMP_TEXT : "\""
        (
            "\\" ~[]
        |
            ~["\""]     // this covers the HIT/CLOU protected space character and also all German Umlauts and szlig.
        )*"\"" > : TXT_MODE
}
<COMMAND_MODE_LS_BRACES> TOKEN : {
    < LS_BRACES_AMPERSAND : "&" > |
    < LS_BRACES_COMMA : "," > |
    < LS_BRACES_RBRACE : "}" > : COMMAND_MODE_LS |
    < LS_BRACES_LBRACKET : "[" > |
    < LS_BRACES_RBRACKET : "]" > |
    < LS_BRACES_NUM : (["0"-"9"])+ > |
    < LS_BRACES_DEC : (["0"-"9"])+("."(["0"-"9"])+)? | ("."(["0"-"9"])+) > |
    < LS_BRACES_ID : [ "_", "a"-"z", "A"-"Z"](["_", "a"-"z", "A"-"Z", "0"-"9"])* > |
    < LS_BRACES_TEXT : "\""
        (
           "\\" ~[]
        |
           ~["\""]     // this covers the HIT/CLOU protected space character and also all German Umlauts and szlig.
        )*"\"" >
}
<COMMAND_MODE_LS_BRACES> SKIP : {
    "\n" | "\r" | "\t" | " "
}
<COMMAND_MODE_HC> TOKEN : {
    < HC_HC : "#^"> |
    < HC_NUM : (["0"-"9"])+ > |
    < HC_LBRACKET : "[" > |
    < HC_RBRACKET : "]" > |
    < HC_ID : [ "_", "a"-"z", "A"-"Z"](["_", "a"-"z", "A"-"Z", "0"-"9"])* > |
    < HC_NAME : "\""
        (
           "\\" ~[]
        |
           ~["\""]     // this covers the HIT/CLOU protected space character and also all German Umlauts and szlig.
        )*"\"" > : TXT_MODE
}
<COMMAND_MODE_HC> SKIP : {
    "\n" | "\r" | "\t" | " "
}

/*  Productions */
/*  CLOU Baustein CB */
ClouBaustein CB() :
{ ClouBausteinElement clouBausteinElement; }
{
    <CLOU_OPENER> clouBausteinElement = CBE() <EOF>
    {
        return clouBausteinElement != null ?
            new ClouBausteinImpl(clouBausteinElement) :
            new ClouBausteinImpl(CodePosition.createZeroPosition(), null );
    }
}

ClouBausteinElementList CBE() :
{ ClouBausteinElement element; ClouBausteinElementList elementList; }
{
    /* CBE production can be resolved to several options, the specific CBEs. And it is nullable, too */
    (
        element = CBES() elementList = CBE()
        {
            return elementList == null ?
                new LastClouBausteinElementList(element) :
                new PairClouBausteinElementList(element, elementList);
        }
    )?
    { return null; }
}

ClouBausteinElement CBES() :
{ ClouBausteinElement element; }
{
    element = IF()
    {
        return element;
    }
    |
    element = FOR()
    {
        return element;
    }
    |
    element = WS()
    {
        return element;
    }
    |
    element = SS()
    {
        return element;
    }
    |
    element = MS()
    {
        return element;
    }
    |
    element = HC()
    {
        return element;
    }
    |
    element = GDS()
    {
        return element;
    }
    |
    element = LDS()
    {
        return element;
    }
    |
    element = AS()
    {
        return element;
    }
    |
    element = IB()
    {
        return element;
    }
    |
    element = GS()
    {
        return element;
    }
    |
    element = JS()
    {
        return element;
    }
    |
    element = ZS()
    {
        return element;
    }
    |
    element = FX()
    {
        return element;
    }
    |
    element = SK()
    {
        return element;
    }
    |
    element = DUMP()
    {
        return element;
    }
    |
    (LOOKAHEAD(4)element = OF()
    {
        return element;
    }
    |
    element = CF()
    {
        return element;
    })
    |
    (LOOKAHEAD(3) element = GLDS()
    {
        return element;
    }
    |
    (LOOKAHEAD(3)element = LLDS()
    {
        return element;
    }
    |
    element = LCS()
    {
        return element;
    }
    ))
    |
    element = DV()
    {
        return element;
    }
    |
    element = PS()
    {
        return element;
    }
    |
    element = SB()
    {
        return element;
    }
}

ForStatement FOR() :
{ Expression repetitionCount; ClouBausteinElement forBody; }
{
    <FS> repetitionCount = E() forBody = CBE() <ENDIF>
    {
        return new ForStatement(repetitionCount, forBody);
    }
}

ConditionalStatement IF() :
{ Expression condition; ClouBausteinElement thenElement; ClouBausteinElement elseElement; }
{
    <IF> condition = E() <IF_COLON> thenElement = THEN() elseElement = ELSE() <ENDIF>
    {
        return new ConditionalStatement(condition, thenElement, elseElement);
    }
}

ClouBausteinElement THEN() :
 { ClouBausteinElement thenStatement; }
 {
     (<THEN> thenStatement = CBE()
     {
         return thenStatement;
     })?
     {
         return null;
     }
 }

 ClouBausteinElement ELSE() :
 { ClouBausteinElement elseStatement; }
 {
     (<ELSE> elseStatement = CBE()
     {
         return elseStatement;
     })?
     {
         return null;
     }
 }

WhileStatement WS() :
{ Token whileToken; Expression condition; ClouBausteinElement whileBody; }
{
    whileToken = <WS> condition = E() <IF_COLON> whileBody = CBE() <ENDIF>
    {
        return new WhileStatement(CodePosition.createFromToken(whileToken), condition, whileBody);
    }
}

SwitchStatement SS() :
{ Expression expression; CaseStatementList caseStatementList; }
{
    <SS> expression = E() caseStatementList = SSPrime() <ENDIF>{
        return new SwitchStatement(expression, caseStatementList);
    }
}

ShellCommand SK() :
{ Token cmdToken; }
{
    <SK> cmdToken = <SK_VAR_ID>
    {
        return new ShellCommand(CodePosition.createFromToken(cmdToken), cmdToken.image);
    }
}

CaseStatementList SSPrime() :
{ CaseStatementList caseStatementList; CaseStatement caseStatement; }
{
    (caseStatement = CASE() caseStatementList = SSPrime()
    {
        return caseStatementList == null ? new LastCaseStatementList(caseStatement) :
            new PairCaseStatementList(caseStatement, caseStatementList);
    })?
    { return null; }
}

CaseStatement CASE() :
{ Token matchToken; ClouBausteinElement clouBausteinElement; }
{
    matchToken = <CA> clouBausteinElement = CBE()
    {
        return new CaseStatementImpl(CodePosition.createFromToken(matchToken), matchToken.image, clouBausteinElement);
    }
}

MacroCallStatement MS() :
{ Token idToken; ExpressionList argumentList; }
{
    <MS> idToken = <MS_ID> argumentList = AL()
    {
        return new MacroCallStatement(CodePosition.createFromToken(idToken), idToken.image, argumentList);
    }
}

ExpressionList AL() :
{ ExpressionList expressionList; }
{
    ((<MS_LPAREN>|<IF_LPAREN>) expressionList = EL() (<MS_RPAREN>|<IF_RPAREN>)
    {
        return expressionList;
    })? { return null; }
}

ExpressionList EL() :
{ Expression expression; ExpressionList expressionList; }
{
    expression = E() expressionList = ELPrime()
    {
        return expressionList == null ? new LastExpressionList(expression) : new PairExpressionList(expression, expressionList);
    }
}

ExpressionList ELPrime() :
{ Expression expression; ExpressionList expressionList; }
{
    ((<MS_COMMA>|<LS_BRACES_COMMA>|<DS_COMMA>|<AS_COMMA>|<SS_COMMA>|<PS_IDX_COMMA>) expression = E() expressionList = ELPrime()
    {
        return expressionList == null ? new LastExpressionList(expression) : new PairExpressionList(expression, expressionList);
    })?{ return null; }
}

IncludeBausteinStatement IB() :
{ Token pathToken; }
{
    <IB> pathToken = <IB_TEXT>
    {
        return new IncludeBausteinStatement(CodePosition.createFromToken(pathToken), pathToken.image);
    }
}

HitCommandStatement HC() :
{ Expression repetitorExpression = null; Token hitCommandNameToken; Token hcToken; Token verstarkerToken = null; }
{
    hcToken = <HC> (verstarkerToken = <HC_HC>)? (repetitorExpression = E()) hitCommandNameToken = <HC_NAME>
    {
        String command = hitCommandNameToken.image.replaceAll("\"", "").replaceAll("\u00c4", "AE").replaceAll("\u00d6", "OE").replaceAll("\u00dc", "UE").replaceAll("[^A-Z:]", "_");
        String[] commandSplit = command.split(":");
        if(commandSplit.length ==2) command = commandSplit[1];
        HitCommandStatement hcStatement = new HitCommandStatement(CodePosition.createFromToken(hcToken),
            HitCommand.valueOf(command), repetitorExpression);
        if(verstarkerToken != null || commandSplit.length == 2) hcStatement.verstarken();
        return hcStatement;
    }
}

WriteStatement DUMP() :
{ Token filenameToken; }
{
    <DUMP> filenameToken = <DUMP_TEXT>
    {
        return new WriteStatement(CodePosition.createFromToken(filenameToken), filenameToken.image);
    }
}

OpenFileCommand OF() :
{ Token fileNameToken; }
{
    <OF> fileNameToken = <FILE_TEXT> <FILE_OPEN> <FILE_READ>
    {
        return new OpenFileCommand(CodePosition.createFromToken(fileNameToken), fileNameToken.image);
    }
}

CloseFileCommand CF() :
{ Token fileNameToken; }
{
    <OF> fileNameToken = <FILE_TEXT> <FILE_CLOSE>
    {
        return new CloseFileCommand(CodePosition.createFromToken(fileNameToken), fileNameToken.image);
    }
}

DynamicValue DV() :
{ Token idToken; }
{
    <DV> idToken = <DV_ID>
    {
        logger.debug(StringUtils.join("Found DynamicValue: varId:", idToken.image));
        return new DynamicValue(CodePosition.createFromToken(idToken), idToken.image);
    }
}

// a PrintStatement prints the current value of a variable. Thus, it looks for an id here, not an E()!
// This might be a limitation of the HIT/CLOU processing engine, where it might be difficult to implement
// a parser that reliably can tell an expression from fixed text within a HIT/CLOU template.
PrintStatement PS() :
{ Expression idExpression; }
{
    <PS> idExpression = E()
    {
        return new PrintStatement(idExpression.getCodePosition(), idExpression);
    }
}

SectionStatement SB() :
{ Token sbToken; }
{
    ( sbToken = <SB> | sbToken = <PS_SB> | sbToken = <PS_IDX_SB> )
    {
        return new SectionStatement(CodePosition.createFromToken(sbToken));
    }
}

AssignmentStatement AS() :
{ Token idToken; Expression expression; }
{
    <AS> idToken = <AS_ID> expression = E()
    {
        logger.debug(StringUtils.join("Found AssignmentStatement: varId:", idToken.image, "; Expression: ", expression));
        return new AssignmentStatement(CodePosition.createFromToken(idToken), idToken.image, expression);
    }
}

GlobalDeclarationStatement GDS() :
{ Token idToken; Expression expression; String formatDefinition; }
{
    <GD> idToken = <DS_ID> expression = E() formatDefinition = DSPrime()
    {
        return new GlobalDeclarationStatement(idToken.image, expression, formatDefinition);
    }
}

String DSPrime() :
{ Token formatToken; }
{
    (
        formatToken = <DS_TEXT>
        {
            return formatToken.image;
        }
    )?
    { return ""; }
}

LocalDeclarationStatement LDS() :
{ Token idToken; Expression expression; String formatDefinition; }
{
    <LD> idToken = <DS_ID> expression = E() formatDefinition = DSPrime()
    {
        return new LocalDeclarationStatement(idToken.image, expression, formatDefinition);
    }
}

GlobalListDeclarationStatement GLDS() :
{ Token varIdToken; Expression listExpression; }
{
    <LIST> varIdToken = <LS_ID> <LS_GD> listExpression = E()
    {
        return new GlobalListDeclarationStatement(CodePosition.createFromToken(varIdToken), varIdToken.image, listExpression);
    }
}

LocalListDeclarationStatement LLDS() :
{ Token varIdToken; Expression listExpression; }
{
    <LIST> varIdToken = <LS_ID> <LS_LD> listExpression = E()
    {
        return new LocalListDeclarationStatement(CodePosition.createFromToken(varIdToken), varIdToken.image, listExpression);
    }
}

ListConcatenationStatement LCS() :
{ Token varIdToken; Expression listExpression; }
{
    <LIST> varIdToken = <LS_ID> <LS_AMPERSAND> listExpression = E()
    {
        return new ListConcatenationStatement(CodePosition.createFromToken(varIdToken), varIdToken.image, listExpression);
    }
}

GStatement GS() :
{ Expression colExpr, valExpr; }
{
    <GS> colExpr = E() valExpr = E()
    {
        return new GStatement(colExpr.getCodePosition(), colExpr, valExpr);
    }
}

JStatement JS() :
{ Expression colExpr, rowExpr; }
{
    <JS> colExpr = E() rowExpr = E()
    {
        return new JStatement(colExpr.getCodePosition(), colExpr, rowExpr);
    }
}

ZStatement ZS() :
{  Expression colExpr, rowExpr; }
{
    <ZS> colExpr = E() rowExpr = E()
    {
        return new ZStatement(colExpr.getCodePosition(), colExpr, rowExpr);
    }
}

Expression E() :
{ Expression lhs, rhs; }
{
    (LOOKAHEAD(2)lhs = T8() rhs = EPrime(lhs)
    {
        return rhs == null ? lhs : rhs;
    })?
    {return null;}
}

Expression EPrime(Expression lhs) :
{ Expression rhs; Expression ePrimeExpression; }
{
    (
        (<IF_OR>|<DS_OR>) rhs = T8() ePrimeExpression = EPrime(rhs)
        {
            return new BinaryOperatorExpression(lhs, BinaryOperator.OR,
                ePrimeExpression != null ? ePrimeExpression : rhs );
        }
    )?
    { return null; }
}

Expression T8() :
{ Expression lhs, rhs;}
{
    lhs = T7() rhs = T8Prime(lhs)
    {return rhs == null ? lhs : rhs;}
}

Expression T8Prime(Expression lhs) :
{ Expression rhs, t8PrimeExpression; }
{
    (
        (<IF_AND>|<DS_AND>|<LS_AMPERSAND>) rhs = T7() t8PrimeExpression = T8Prime(rhs)
        {
            return new BinaryOperatorExpression(lhs, BinaryOperator.AND,
                t8PrimeExpression != null ? t8PrimeExpression : rhs );
        }
    )?
    { return null; }
}

Expression T7() :
{ Expression lhs, rhs; }
{
    lhs = T6() rhs = T7Prime(lhs)
    {
        return rhs != null ? rhs : lhs;
    }
}

Expression T7Prime(Expression lhs) :
{ Expression rhs, t7PrimeExpression; }
{
    (
        (<IF_XOR>|<DS_XOR>|<FOR_XOR>) rhs = T6() t7PrimeExpression = T7Prime(rhs)
        {
            return new BinaryOperatorExpression(lhs, BinaryOperator.XOR,
                t7PrimeExpression != null ? t7PrimeExpression : rhs );
        }
    )?
    { return null; }
}

Expression T6() :
{ Expression lhs, rhs; }
{
    lhs = T5() rhs = T6Prime(lhs)
    {
        return rhs != null ? rhs : lhs;
    }
}

Expression T6Prime(Expression lhs) :
{ Expression rhs, t6PrimeExpression; }
{
    (
        (<IF_EQ>|<DS_EQ>|<IF_EQ_STRICT>|<DS_EQ_STRICT>|<FOR_EQ_STRICT>) rhs = T5() t6PrimeExpression = T6Prime(rhs)
        {
            return new BinaryOperatorExpression(lhs, BinaryOperator.EQ,
                t6PrimeExpression != null ? t6PrimeExpression : rhs );
        }
        |
        (<IF_NEQ>|<DS_NEQ>|<FOR_NEQ>) rhs = T5() t6PrimeExpression = T6Prime(rhs)
        {
            return new BinaryOperatorExpression(lhs, BinaryOperator.NEQ,
                t6PrimeExpression != null ? t6PrimeExpression : rhs);
        }
    )?
    { return null; }
}

Expression T5() :
{ Expression lhs, rhs; }
{
    lhs = T4() rhs = T5Prime(lhs)
    {
        return rhs != null ? rhs : lhs;
    }
}

Expression T5Prime(Expression lhs) :
{ Expression rhs, t5PrimeExpression; }
{
    (
        (<IF_LT>|<DS_LT>|<FOR_LT>) rhs = T4() t5PrimeExpression = T5Prime(rhs)
        {
            return new BinaryOperatorExpression(lhs, BinaryOperator.LT,
                t5PrimeExpression != null ? t5PrimeExpression : rhs );
        }
        |
        (<IF_LTE>|<DS_LTE>|<FOR_LTE>) rhs = T4() t5PrimeExpression = T5Prime(rhs)
        {
            return new BinaryOperatorExpression(lhs, BinaryOperator.LTE,
                t5PrimeExpression != null ? t5PrimeExpression : rhs );
        }
        |
        (<IF_GT>|<DS_GT>|<FOR_GT>) rhs = T4() t5PrimeExpression = T5Prime(rhs)
        {
            return new BinaryOperatorExpression(lhs, BinaryOperator.GT,
                t5PrimeExpression != null ? t5PrimeExpression : rhs );
        }
        |
        (<IF_GTE>|<DS_GTE>|<FOR_GTE>) rhs = T4() t5PrimeExpression = T5Prime(rhs)
        {
            return new BinaryOperatorExpression(lhs, BinaryOperator.GTE,
                t5PrimeExpression != null ? t5PrimeExpression : rhs );
        }
    )?
    { return null; }
}

Expression T4() :
{ Expression lhs, rhs; }
{
    lhs = T3() rhs = T4Prime(lhs)
    {
        return rhs != null ? rhs : lhs;
    }
}

Expression T4Prime(Expression lhs) :
{ Expression rhs, t4PrimeExpression; }
{
    (
        (<IF_PLUS>|<DS_PLUS>|<AS_PLUS>|<FOR_PLUS>) rhs = T3() t4PrimeExpression = T4Prime(rhs)
        {
            return new BinaryOperatorExpression(lhs, BinaryOperator.PLUS,
                t4PrimeExpression != null ? t4PrimeExpression : rhs );
        }
        |
        (<IF_MINUS>|<DS_MINUS>|<AS_MINUS>|<FOR_MINUS>) rhs = T3() t4PrimeExpression = T4Prime(rhs)
        {
            return new BinaryOperatorExpression(lhs, BinaryOperator.MINUS,
                t4PrimeExpression != null ? t4PrimeExpression : rhs );
        }
        |
        (<DS_STRING_CONCAT>|<AS_STRING_CONCAT>) rhs = T3() t4PrimeExpression = T4Prime(rhs)
        {
            return new BinaryOperatorExpression(lhs, BinaryOperator.STRING_CONCAT, t4PrimeExpression != null ? t4PrimeExpression : rhs);
        }
    )?
    { return null; }
}

Expression T3() :
{ Expression lhs, rhs; }
{
    lhs = T2() rhs = T3Prime(lhs)
    {
        return rhs != null ? rhs : lhs;
    }
}

Expression T3Prime(Expression lhs) :
{ Expression rhs, t3PrimeExpression; }
{
    (
        (<IF_TIMES>|<DS_TIMES>|<AS_TIMES>|<FOR_TIMES>) rhs = T2() t3PrimeExpression = T3Prime(rhs)
        {
               return new BinaryOperatorExpression(lhs, BinaryOperator.TIMES,
                t3PrimeExpression != null ? t3PrimeExpression : rhs );
        }
        |
        (<IF_DIV>|<DS_DIV>|<AS_DIV>|<FOR_DIV>) rhs = T2() t3PrimeExpression = T3Prime(rhs)
        {
               return new BinaryOperatorExpression(lhs, BinaryOperator.DIV,
                t3PrimeExpression != null ? t3PrimeExpression : rhs );
        }
    )?
    { return null; }
}

Expression T2() :
{ Expression f; }
{
    (
        f = F()
    )
    {
        return f;
    }
    |
    (
        (<IF_NOT>|<DS_NOT>|<FOR_NOT>) f = F()
    )
    {
        return new UnaryOperatorExpression(UnaryOperator.NOT, f);
    }
}

Expression F() :
{
    Token valueToken; ExpressionList expressionList;
    // idxExp1 and idxExp2 are needed for IdExpressions that have indices as in names[5] and name[1,5]
    Expression buffer; Expression idxExp1 = null; Expression idxExp2 = null;
}
{
    ( valueToken = <IF_NUM> | valueToken = <DS_NUM> | valueToken = <AS_NUM> | valueToken = <MS_NUM> |
        valueToken = <LS_BRACES_NUM> | valueToken = <SS_NUM> | valueToken = <HC_NUM> | valueToken = <FOR_NUM> |
        valueToken = <PS_IDX_NUM> | valueToken = <PS_NUM> )
    {
        return new NumExpression(CodePosition.createFromToken(valueToken), Integer.parseInt(valueToken.image));
    }
    |
    ( valueToken = <IF_DEC> | valueToken = <DS_DEC> | valueToken = <AS_DEC> | valueToken = <MS_DEC> |
        valueToken = <LS_BRACES_DEC> | valueToken = <FOR_DEC> | valueToken = <PS_IDX_DEC> | valueToken = <PS_DEC> )
    {
        return new DecimalExpression(CodePosition.createFromToken(valueToken), Double.parseDouble(valueToken.image));
    }
    |
    ( valueToken = <IF_TEXT> | valueToken = <DS_TEXT> | valueToken = <AS_TEXT> | valueToken = <MS_TEXT> |
        valueToken = <LS_BRACES_TEXT> | valueToken = <FOR_TEXT>)
    {
        return new TextExpression(CodePosition.createFromToken(valueToken), valueToken.image);
    }
    |
    ((<SS_SHELLVAR>|<AS_SHELLVAR>|<IF_SHELLVAR>) (<SS_LPAREN>|<AS_LPAREN>|<IF_LPAREN>)
        (<SS_QUOTE>valueToken = <SS_SHELLVAR_ID><SS_QUOTE> | valueToken = <AS_TEXT> | valueToken = <IF_TEXT> )
        (<SS_RPAREN>|<AS_RPAREN>|<IF_RPAREN>))
    {
        // TODO 2016-07-08 I vote to delete this since SHELLVARIABLE in fact is a function call and has to be handled there
        // ShellVariable evaluations in assignment statements #=
        // deliver the variableId with quotes. They have to be truncated
        // before storage
        return new ShellVariableExpression(CodePosition.createFromToken(valueToken), valueToken.image.replaceAll("\"", ""));
    }
    |
    // implements clou standard function, e.g. listlen("varname")
    LOOKAHEAD(2) (( valueToken = <IF_ID> | valueToken = <AS_ID> | valueToken = <FOR_ID> )
        ( <IF_LPAREN> | <AS_LPAREN> | <FOR_LPAREN> )
        expressionList = EL() ( <IF_RPAREN> | <AS_RPAREN> | <FOR_RPAREN> ))
    {
        return new ClouFunctionCall(CodePosition.createFromToken(valueToken), valueToken.image, expressionList);
    }
    |
    // implements IdExpressions. An IdExpression holds a string that is interpreted as the name of a variable.
    // Nota bene: An IdExpression can refer to a scalar (e.g. firstName), or to a list (e.g. names), or to an
    // entry within a list (e.g. names[4]), or another interesting substring construct as in myName[1,5] which
    // results in the substring from char 1 to char 5 in myName.
    (( valueToken = <IF_ID> | valueToken = <DS_ID> | valueToken = <SS_ID> |
        valueToken = <AS_ID> | valueToken = <MS_ID> | valueToken = <LS_ID> | valueToken = <LS_BRACES_ID> |
        valueToken = <HC_ID> | valueToken = <FOR_ID> | valueToken = <PS_IDX_ID> )
    // if the id is a reference to a value within a field there will follow a bracket expression, e.g. names[5].
    // from the perspective of the IdExpression factor, bracket expressions are optional. There are two kinds
    // of bracket expressions: a pair of expressions with a single expression inside that can be evaluated to a
    // numeric value -> referencing an entry in a field. a pair of expressions with an expression list inside,
    // holding exactly two values -> another way in HIT/CLOU to get a substring.
    (
        ( <IF_LBRACKET> | <DS_LBRACKET> | <SS_LBRACKET> | <AS_LBRACKET> | <MS_LBRACKET> | <LS_LBRACKET> | <LS_BRACES_LBRACKET> |
            <HC_LBRACKET> | <FOR_LBRACKET> | <PS_IDX_LBRACKET> )
            buffer = EL()
        ( <IF_RBRACKET> | <DS_RBRACKET> | <SS_RBRACKET> | <AS_RBRACKET> | <MS_RBRACKET> | <LS_RBRACKET> | <LS_BRACES_RBRACKET> |
            <HC_RBRACKET> | <FOR_RBRACKET> | <PS_IDX_RBRACKET> )
        {
            if(idxExp1 == null){
                idxExp1 = buffer;
            } else if(idxExp2 == null){
                idxExp2 = buffer;
            } else {
                throw new ClouParserException(StringUtils.join(
                    "Could not parse CLOU text component. Only 2 index expressions are allowed for variables. I have found at least three!"));
            }
        }
    )*)
    {
        return new IdExpression(CodePosition.createFromToken(valueToken), valueToken.image, idxExp1, idxExp2);
    }
    |
    // IdExpressions revisited: PrintStatement. PrintStatements behave differently from other Statements in that they
    // have no end demarcation, but just end after the variableId was read, and on goes fixed text. This behavior
    // requires special treatment for indexed variables
    ((valueToken = <PS_ID>)
    (
        <PS_IDX_CHECK_LBRACKET> buffer = EL() <PS_IDX_RBRACKET>
        {
            if(idxExp1 == null){
                idxExp1 = buffer;
            } else if (idxExp2 == null){
                idxExp2 = buffer;
            } else {
                throw new ClouParserException(StringUtils.join(
                    "Could not parse CLOU text component. Only 2 index expressions are allowed for variable IDs in PrintStatements. I have found at least three!"));
            }
        }
    )*)
    {
        return new IdExpression(CodePosition.createFromToken(valueToken), valueToken.image, idxExp1, idxExp2);
    }
    |
    LOOKAHEAD(2)(<LS_LBRACE> <LS_BRACES_RBRACE>)
    {
        return null;
    }
    |
    (<LS_LBRACE> expressionList = EL() <LS_BRACES_RBRACE>)
    {
        return expressionList;
    }
}

FixedText FX() :
{ Token valueToken; }
{
    ( valueToken = <FIXED_TEXT> | valueToken = <PS_IDX_CHECK_FIXED_TEXT> )
    {
        return FixedText.create(CodePosition.createFromToken(valueToken), valueToken.image);
    }
}
